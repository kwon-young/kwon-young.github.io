<!doctype html><html><head><meta charset=utf-8><title>Epsilon · Kwon-Young Choi</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical href=https://kwon-young.github.io/blog/2023/epsilon/><meta name=author content="Kwon-Young Choi"><link rel=stylesheet href=https://kwon-young.github.io/node_modules/normalize.css/normalize.css><link rel=stylesheet href=https://kwon-young.github.io/node_modules/firacode/distr/fira_code.css><link rel=stylesheet href=https://kwon-young.github.io/css/nanum-gothic-coding.css><link rel=stylesheet href=https://kwon-young.github.io/css/style.css></head><body><header><p></p><img height=100vh src=/sam_taeguk.png><h1>최권영</h1></header><div id=main><nav><a href=https://kwon-young.github.io/>home</a> &#183;
<a href=https://kwon-young.github.io/blog>blog</a> &#183;
<a rel=me href=https://kwon-young.github.io/about>about</a></nav><main><article><header><h1>Epsilon</h1><time datetime=2023-11-13T09:09:04+09:00>2023-11-13</time></header><h1 id=epsilon>Epsilon</h1><p>This blog post is the second of a series on writing a pure prolog grammar to relate graphical primitives with high level semantic constructs.
If you have not already, I advise to read the <a href=https://kwon-young.github.io/blog/2023/triangle>first post of the series</a> that introduce the context and motivation of the subject at hand.</p><p>In the previous post, I have introduced how we can write a pure DCG predicate to relate a list of segments with geometrical figures like triangles and equilateral triangles.
Let&rsquo;s begin right from the last example of recognizing equilateral triangles:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>:- <span style=color:#a6e22e>use_module</span>(<span style=color:#a6e22e>library</span>(<span style=color:#e6db74>clpBNR</span>)).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>seg_length</span>(<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(X1, Y1), <span style=color:#a6e22e>point</span>(X2, Y2)), Len) :-
</span></span><span style=display:flex><span>   { Len <span style=color:#f92672>==</span> <span style=color:#a6e22e>sqrt</span>((X2 <span style=color:#f92672>-</span> X1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (Y2 <span style=color:#f92672>-</span> Y1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span>) }.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>triangle</span>(A, B, C), <span style=color:#a6e22e>seg</span>(A, B), <span style=color:#a6e22e>seg</span>(B, C), <span style=color:#a6e22e>seg</span>(C, A)).
</span></span><span style=display:flex><span><span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>equilateral_triangle</span>(A, B, C), Seg1, Seg2, Seg3) :-
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>triangle</span>(A, B, C), Seg1, Seg2, Seg3),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>seg_length</span>(Seg1, Len),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>seg_length</span>(Seg2, Len),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>seg_length</span>(Seg3, Len).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>term</span>(X) --&gt;
</span></span><span style=display:flex><span>   [X].
</span></span><span style=display:flex><span><span style=color:#a6e22e>term</span>(X), [CurX] --&gt;
</span></span><span style=display:flex><span>   [CurX],
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(X).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>triangle_dcg</span>(Triangle) --&gt;
</span></span><span style=display:flex><span>   { <span style=color:#a6e22e>triangle_cond</span>(Triangle, Seg1, Seg2, Seg3) },
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg1),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg2),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg3).
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> {Y <span style=color:#f92672>==</span> <span style=color:#a6e22e>sqrt</span>(<span style=color:#ae81ff>3</span>)},
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(A, B, C)),
</span></span><span style=display:flex><span>          [<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, Y)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, Y), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))]).
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>equilateral_triangle</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, Y)),
</span></span><span style=display:flex><span>Y<span style=color:#e6db74>::</span> <span style=color:#ae81ff>1.732050807568877</span>... .
</span></span></code></pre></div><h2 id=reals>Reals</h2><p>Here, \( \sqrt{3} \) is a real number. It is even called an irrational number, meaning that there is no finite finite floating point representation of that number.</p><p>One of the immediate consequence of this is that if we copy the number printed by the prolog top level and use it in our query, the query will fail:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(A, B, C)),
</span></span><span style=display:flex><span>          [<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.732050807568877</span>)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.732050807568877</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))]).
</span></span><span style=display:flex><span><span style=color:#e6db74>false</span>.
</span></span></code></pre></div><p>This is because clpBNR is able to distinguish \( \sqrt{3} \) and 1.732050807568877 and say that the equality relation <code>==</code> does not hold between these two numbers.</p><p>We introduced this imprecision by copy pasting the number, but much bigger imprecision could be introduced if the graphical primitives were produced by external components.
Maybe we extracted the graphical primitives from a geometry application, or recognize them from a learned shape detector model.</p><p>For example, the music engraving software I am using for my music grammar called Verovio engrave music scores with a precision of 0.05 pixels.
This means that sometimes, symbols or lines are not perfectly aligned as they should but have small defects invisible when the music score is looked at at a reasonable scale.</p><p>Logically speaking, if the <code>Y</code> coordinate of the second point of our triangle is not exactly \( \sqrt{3} \), it should not be an equilateral triangle.
But, as we have seen, for many extra logical reasons, we can be in a situation where we want to recognize, generate and test equilateral triangles with only approximate coordinate values.</p><p>In order to deal with such imprecision, we are going to fully forget about the <code>==</code> relation and instead use an upper bound imprecision called <code>Epsilon</code>.</p><h2 id=epsilon-as-an-upper-bound-imprecision>Epsilon as an upper bound imprecision</h2><p>So, let&rsquo;s go back to our <code>seg_length/2</code> predicate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>seg_length</span>(<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(X1, Y1), <span style=color:#a6e22e>point</span>(X2, Y2)), Len) :-
</span></span><span style=display:flex><span>   { Len <span style=color:#f92672>==</span> <span style=color:#a6e22e>sqrt</span>((X2 <span style=color:#f92672>-</span> X1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (Y2 <span style=color:#f92672>-</span> Y1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span>) }.
</span></span></code></pre></div><p>The goal is to replace the <code>==</code> relation with something less restrictive.
Let&rsquo;s say we want the predicate to succeed if difference between the length computed from the segment and the given length <code>Len</code> is small enough.
Let&rsquo;s say if the difference is smaller than 0.1, we consider that this relation should hold.
For this, let&rsquo;s write a predicate called <code>eps(A, B)</code> which holds if the distance between A and B is smaller than 0.1:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>eps</span>(A, B) :-
</span></span><span style=display:flex><span>   { <span style=color:#a6e22e>abs</span>(A <span style=color:#f92672>-</span> B) <span style=color:#f92672>=&lt;</span> <span style=color:#ae81ff>0.1</span> }.
</span></span></code></pre></div><p>Since we don&rsquo;t know whether A or B is the bigger one, we use the absolute value of the difference between A and B.</p><p>Let&rsquo;s test this predicate with different queries:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>eps</span>(A, B).
</span></span><span style=display:flex><span>A<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span>B<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>eps</span>(<span style=color:#ae81ff>1</span>, B).
</span></span><span style=display:flex><span>B<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#ae81ff>0.8999999999999999</span>, <span style=color:#ae81ff>1.1</span>).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>eps</span>(A, <span style=color:#ae81ff>1</span>).
</span></span><span style=display:flex><span>A<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#ae81ff>0.8999999999999999</span>, <span style=color:#ae81ff>1.1</span>).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>eps</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>).
</span></span><span style=display:flex><span><span style=color:#e6db74>true</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>eps</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.2</span>).
</span></span><span style=display:flex><span><span style=color:#e6db74>false</span>.
</span></span></code></pre></div><p>The most general query is not very informative here, but clpBNR does remember the constraints imposed inside the <code>eps/2</code> predicate.
The following two queries does shows us more information and correctly narrows down the variable to \( \pm 0.1 \) of 1.</p><p>The final two queries could have been done with basic prolog arithmetic so no real surprises here.</p><p>Let&rsquo;s apply <code>eps/2</code> to our original <code>seg_length/2</code> predicate:</p><pre tabindex=0><code>seg_length(seg(point(X1, Y1), point(X2, Y2)), Len) :-
   eps(Len, sqrt((X2 - X1)**2 + (Y2 - Y1)**2)).
</code></pre><p>And retry our previously failing query:</p><pre tabindex=0><code>?- phrase(triangle_dcg(equilateral_triangle(A, B, C)),
          [seg(point(0, 0), point(2, 0)),
           seg(point(2, 0), point(1, 1.732050807568877)),
           seg(point(1, 1.732050807568877), point(0, 0))]).
A = point(0, 0),
B = point(2, 0),
C = point(1, 1.732050807568877) .
</code></pre><p>As expected, the queries now succeeds !</p><h2 id=eps-as-a-configurable-upper-bound-precision>Eps as a <strong>configurable</strong> upper bound precision</h2><p>Let&rsquo;s go back to our <code>eps/2</code> predicate.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>eps</span>(A, B) :-
</span></span><span style=display:flex><span>   { <span style=color:#a6e22e>abs</span>(A <span style=color:#f92672>-</span> B) <span style=color:#f92672>=&lt;</span> <span style=color:#ae81ff>0.1</span> }.
</span></span></code></pre></div><p>Using 0.1 as an upper bound imprecision is an arbitrary choice.
What if our application needs a smaller imprecision so that it does not show on the screen ?
What if we want to recognize some triangles, but we don&rsquo;t know how precise was the recognition process of the graphical primitives ?</p><p>Well, let&rsquo;s make the upper bound configurable and see what happens:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>eps</span>(Eps, A, B) :-
</span></span><span style=display:flex><span>   { <span style=color:#a6e22e>abs</span>(A <span style=color:#f92672>-</span> B) <span style=color:#f92672>=&lt;</span> Eps }.
</span></span></code></pre></div><p>This means we will have to update the whole code and grammar to carry this new variable.
Updating <code>seg_length/2</code> is easy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>seg_length</span>(<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(X1, Y1), <span style=color:#a6e22e>point</span>(X2, Y2)), Len, Eps) :-
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>eps</span>(Eps, Len, <span style=color:#a6e22e>sqrt</span>((X2 <span style=color:#f92672>-</span> X1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (Y2 <span style=color:#f92672>-</span> Y1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span>)).
</span></span></code></pre></div><p>Let&rsquo;s continue with <code>triangle_cond/2</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>triangle</span>(A, B, C), <span style=color:#a6e22e>seg</span>(A, B), <span style=color:#a6e22e>seg</span>(B, C), <span style=color:#a6e22e>seg</span>(C, A), <span style=color:#66d9ef>_</span>).
</span></span><span style=display:flex><span><span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>equilateral_triangle</span>(A, B, C, Len), Seg1, Seg2, Seg3, Eps) :-
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>triangle</span>(A, B, C), Seg1, Seg2, Seg3, Eps),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>seg_length</span>(Seg1, Len, Eps),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>seg_length</span>(Seg2, Len, Eps),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>seg_length</span>(Seg3, Len, Eps).
</span></span></code></pre></div><p>Okay, we have introduced the use of epsilon for checking the segment length.
We also add a fourth argument to the <code>equilateral_triangle/4</code> term to be able to see and specify the length of the sides.</p><p>We are almost finished, we just need to update the grammar:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>triangle_dcg</span>(Triangle, Eps) --&gt;
</span></span><span style=display:flex><span>   { <span style=color:#a6e22e>triangle_cond</span>(Triangle, Seg1, Seg2, Seg3, Eps) },
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg1),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg2),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg3).
</span></span></code></pre></div><p>And we are done !</p><p>Let&rsquo;s now think what we can do with such a formalism.
For now, I have identified three mode of operations:</p><ol><li>test</li><li>generate</li><li>recognize</li></ol><h3 id=test>Test</h3><p>In test mode, we can now test the grammar with a set of fully annotated data.
In our current example, we know that the equilateral triangle with points (0, 0), (2, 0), (1, ~1.73) and side length of 2 should match the segments with corresponding points.</p><p>Let&rsquo;s try it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                                            <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                                            <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.73</span>), <span style=color:#ae81ff>2</span>), Eps),
</span></span><span style=display:flex><span>          [<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.73</span>)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.73</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))]).
</span></span><span style=display:flex><span>Eps<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#ae81ff>0.0017757883560709509</span>, <span style=color:#ae81ff>1.0</span>Inf) ;
</span></span><span style=display:flex><span><span style=color:#e6db74>false</span>.
</span></span></code></pre></div><p>Interesting !
The fact that we can simply provide both side of the equation and test if the code succeeds or fails means that the code is highly testable.
We could make a test suite with different triangles and test them in parallel.
This means that we can later expand the grammar without fear of regressions.</p><blockquote><p><strong>Note</strong>:
Trust me, I have spent my whole PhD writing this kind of graphical grammars with no test framework in place.
It was a <strong>Nightmare</strong> :(</p></blockquote><p>Here, clpBNR also tells us that this rule would succeed with an upper bound error over 0.0017757883560709509.
However, we still don&rsquo;t know if the real upper is ~0.00177&mldr; or higher.
But we can ask clpBNR to find the smallest error which would still allow the query to succeed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                                            <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                                            <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.73</span>), <span style=color:#ae81ff>2</span>), Eps),
</span></span><span style=display:flex><span>          [<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.73</span>)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.73</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))]),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>global_minimize</span>(Eps, Eps).
</span></span><span style=display:flex><span>Eps<span style=color:#e6db74>::</span> <span style=color:#ae81ff>0.00177</span>... .
</span></span><span style=display:flex><span><span style=color:#e6db74>false</span>.
</span></span></code></pre></div><p>With the predicate <code>global_minimize/2</code>, clpBNR has gradually reduced the epsilon interval from its upper bound and found that it can not go smaller than 0.00177 while respecting all constraints.
Imagine now that the graphical primitives were extracted from an image.
This means that we can now compute the largest error of the recognition process that is relevant for the semantic reconstruction of the document !
Outside of this work, I have never encountered such a end-goal oriented computation of errors of a recognition process !
Of course, you can compute metrics about the recognition process.
But those metrics are only weakly linked to the quality of the semantic recognition process.</p><h3 id=recognize>Recognize</h3><p>I categorize a query as a recognition query if the graphical primitives are given but not the semantic structure.
Unfortunately, in this mode, if we do not specify a reasonable epsilon, we will not get any useful answers because with a sufficiently big error, any semantic structures allowed by the grammar will be produced.</p><p>Fortunately, we can use the previous testing mode on a few annotated data to guestimate a reasonable epsilon value and use that for the recognition process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> Eps<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0.00178</span>), <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(A, B, C, Len), Eps),
</span></span><span style=display:flex><span>       [<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.73</span>)),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.73</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))]).
</span></span><span style=display:flex><span>A <span style=color:#f92672>=</span> <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>B <span style=color:#f92672>=</span> <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>C <span style=color:#f92672>=</span> <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1.73</span>),
</span></span><span style=display:flex><span>Eps<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0.0017800000000000001</span>),
</span></span><span style=display:flex><span>Len<span style=color:#e6db74>::</span> <span style=color:#ae81ff>2.00</span>... .
</span></span></code></pre></div><h3 id=generate>Generate</h3><p>Finally, by using a epsilon of 0, we can go back to a perfect logical world and generate graphical structures that perfectly matches a given semantic structures:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>sqrt</span>(<span style=color:#ae81ff>3</span>)), <span style=color:#ae81ff>2</span>), <span style=color:#ae81ff>0</span>), L).
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>sqrt</span>(<span style=color:#ae81ff>3</span>))),
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>sqrt</span>(<span style=color:#ae81ff>3</span>)) , <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))] .
</span></span></code></pre></div><p>This mode is mostly useful to test the grammar code and verify its purity and bidirectionality.</p><h2 id=conclusion>Conclusion</h2><p>With this article, I have introduced a way to deal with imprecision over reals rejecting the equality relationship.
Instead, we use an explicit imprecision upper bound epsilon and do a comparison over a distance computed between two reals.</p><p>From this formulation, I showed how I can measure and constrain the imprecision for the different mode of testing, recognition and generation.</p><p>Now, let&rsquo;s say that we extend the grammar to recognize a lot of other kind of geometrical figures.
That means that each of the <code>{triangle,rectangle,...}_cond</code> predicates will need epsilon to measures their imprecision as well.
This means that we need to refer to our epsilon all over our grammar !
I think the subject of my next post will be: how to deal with state ?</p><h3 id=exercise>Exercise</h3><p>By the way, have you notice a sneaky use of the <code>==</code> relationship in the first clause of <code>triangle_cond/3</code> ?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>triangle</span>(A, B, C), <span style=color:#a6e22e>seg</span>(A, B), <span style=color:#a6e22e>seg</span>(B, C), <span style=color:#a6e22e>seg</span>(C, A), <span style=color:#66d9ef>_</span>Eps).
</span></span></code></pre></div><p>Let me know if you find it and how you would use <code>eps/3</code> to replace them !</p></article></main><footer>© 2024 Kwon-Young Choi
<a rel=license href=http://creativecommons.org/licenses/by/3.0/us/><img alt="Creative Commons License" src=https://i.creativecommons.org/l/by/3.0/us/80x15.png></a></footer></div></body></html>