<!doctype html><html><head><meta charset=utf-8><title>Triangle · Kwon-Young Choi</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical href=https://kwon-young.github.io/blog/2023/triangle/><meta name=author content="Kwon-Young Choi"><link rel=stylesheet href=https://kwon-young.github.io/node_modules/normalize.css/normalize.css><link rel=stylesheet href=https://kwon-young.github.io/node_modules/firacode/distr/fira_code.css><link rel=stylesheet href=https://kwon-young.github.io/css/nanum-gothic-coding.css><link rel=stylesheet href=https://kwon-young.github.io/css/style.css></head><body><header><p></p><img height=100vh src=/sam_taeguk.png><h1>최권영</h1></header><div id=main><nav><a href=https://kwon-young.github.io/>home</a> &#183;
<a href=https://kwon-young.github.io/blog>blog</a> &#183;
<a rel=me href=https://kwon-young.github.io/about>about</a></nav><main><article><header><h1>Triangle</h1><time datetime=2023-10-31T17:11:09+01:00>2023-10-31</time></header><script type=text/javascript src=https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js></script>
<link rel=stylesheet type=text/css href=https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css><p>Since it has been a few years I started working on my <a href=https://github.com/kwon-young/music>music notation grammar</a>, I thought about how I could explain what I am doing to other peoples.
I believe that for anyone else than me, some of the prolog code in that repository might be quite hard to understand.</p><p>That&rsquo;s why I thought of a simplified example that could explain some of the logic and design decision behind the project.
This post is only part 1 of a series I plan to do on the subject.</p><h2 id=introduction>Introduction</h2><p>So first, here is what we want to do.
The basic idea of the project is to write a program that relates graphical primitives with high level semantic structure.
Let&rsquo;s take concrete examples of program that do exactly that:</p><ul><li><p>programs like LaTeX, MuseScore or even Word take a high level description of a document and can produce a graphical representation of the document consisting of a few graphical primitives like glyphes, segment, etc.</p></li><li><p>programs like OCRs can take an image of a document and can recognize the text inside of the document image in order to produce a high level representation of the document.
Although OCRs takes as input an image of a document instead of graphical primitives, most of them will first recognize a small number of graphical primitives like letters or words and then reconstruct high level semantic structures like paragraph, titles etc.</p></li><li><p>My own project linked above target is to write a graphical grammar of the common music notation.
This notation is used to typeset music score since the early of 18th century and is a very complex set of rules specifying the use and placement of music symbols to transcribe music on paper.
Therefore, the goal I have for this project is to be able to write a prolog program that relates music scores in the MEI format (a format akin to MusicXML) with a set of graphical primitives like music symbols and segments.</p></li></ul><p>Music notation is a very complicated beast so we will simplify things a lot in this first post and try something simpler: middle school geometry!</p><h2 id=basics>Basics</h2><p>Let&rsquo;s start with a much more basic program.
A program that relates basic 2D euclidean geometrical figures with their graphical primitives.
So, for example, let&rsquo;s take the most basic geometric figure: the triangle.
And for graphical primitives, let&rsquo;s limit ourselves to points and segments.</p><p>We will use prolog compound terms to manipulate these data structures:</p><ul><li>A 2D point with coordinates X, Y: <code>point(X, Y)</code></li><li>A segment, which is a pair of points Start and End: <code>seg(Start, End)</code></li><li>A triangle, which can be represented as three points: <code>triangle(A, B, C)</code></li></ul><p>The graphical representation of a triangle ABC is done by drawing three segments:</p><ul><li>one from point A to point B</li><li>one from point B to point C</li><li>one from point C to point A</li></ul><div id=jxgbox class=jxgbox style=width:400px;height:400px></div><script type=text/javascript>var board=JXG.JSXGraph.initBoard("jxgbox",{boundingbox:[-7,7,7,-7],axis:!0}),p=board.create("point",[-3,3],{name:"A"}),p=board.create("point",[3,3],{name:"B"}),p=board.create("point",[2,-2],{name:"C"}),li=board.create("line",["A","B"],{straightFirst:!1,straightLast:!1,strokeColor:"#000000",strokeWidth:2}),li=board.create("line",["B","C"],{straightFirst:!1,straightLast:!1,strokeColor:"#000000",strokeWidth:2}),li=board.create("line",["C","A"],{straightFirst:!1,straightLast:!1,strokeColor:"#000000",strokeWidth:2})</script><p>Let&rsquo;s translate this to prolog:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>triangle</span>(A, B, C), <span style=color:#a6e22e>seg</span>(A, B), <span style=color:#a6e22e>seg</span>(B, C), <span style=color:#a6e22e>seg</span>(C, A)).
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>:
A little note about code convention in this post: predicates that relates geometrical figures with graphical primitives will always end in <code>_cond</code></p></blockquote><p>Interestingly, this knowledge can be reduced to a single prolog fact.
One thing I love about this line of code is that prolog gives us the ability to specify only the knowledge we are interested in.
Notice how we didn&rsquo;t had to define how a point is represented here.
We could use this code with 2D points, but also 3D or in any number of dimension.
We could also use atoms as points, like <code>'A'</code>, if we are doing some abstract geometry application.
Finally, by using variables instead of ground term for points, we can represent any triangle in the infinite set of all ground triangles!</p><p>Let&rsquo;s move on to the next step, which is to relate this triangle with a list of graphical primitives.
Since, we want to compose and manipulate multiple geometrical figures with a single list of graphical primitives, we will use the prolog DCG notation which is well suited for this use case:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>triangle_dcg</span>(Triangle) --&gt;
</span></span><span style=display:flex><span>   { <span style=color:#a6e22e>triangle_cond</span>(Triangle, Seg1, Seg2, Seg3) },
</span></span><span style=display:flex><span>   [Seg1, Seg2, Seg3].
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>:
A little note about code convention in this post: DCG predicates that could be confused with plain compound terms will always end in <code>_dcg</code></p></blockquote><p>For those that are not familiar with the DCG notation, <a href=https://www.metalevel.at/prolog/dcg>here is a good primer</a>.
If you are already familiar with DCGs, you can just skip the paragraph below.</p><p>To just explain briefly, a DCG predicate can be used to describe a list.
It has this weird neck <code>--></code> and the arity is annotated with a double shlash like this: <code>triangle_dcg//1</code>.
The reason for the double slash is because, internally, prolog translate DCG predicates by adding 2 additional parameters to the head of the clause.
This two additional predicates represent a difference list, which is threaded through inside the body of the DCG predicate.
If you don&rsquo;t know what is a difference list, it&rsquo;s okay, we won&rsquo;t need it here, but it is a very useful prolog pattern to learn.
The braces <code>{}</code> around <code>triangle_cond/4</code> is there to tell prolog that <code>triangle_cond/4</code> is not a DCG predicate but a plain prolog predicate to call normally.</p><blockquote><p><strong>NOTE</strong>:
A little remark on this idea to relates a list of graphical primitives with high level construct with a grammar.
I believe this type of idea was very popular in the 90s.
I was exposed to it through my PhD adviser, Bertrand Coüasnon, which implemented this idea in his thesis with the <a href=https://ieeexplore.ieee.org/abstract/document/953786>DMOS system</a> in a lambda prolog dialect with a grammar formalism called EPF.</p></blockquote><p>Let&rsquo;s see how we can use this DCG in the prolog top level by posting the most general query:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(Triangle), L, R).
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C),
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A)|R].
</span></span></code></pre></div><p>We can see that prolog has build us a <code>triangle</code> compound term together with 3 segments with the correct set of points.
As you can see the pair <code>L</code> and <code>R</code> is a difference list where <code>R</code> is the tail of the list <code>L</code>.
This allows us to compose multiple DCG predicates as we will see later.
If we want to close the list, we can just call the <code>phrase/2</code> predicate without the <code>R</code> argument.</p><p>We can already do a lot of different things with this predicate.
We can <em>draw</em> a specific triangle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>triangle</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>)), L, R).
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>)|R].
</span></span></code></pre></div><p>We can recognize a triangle from a set of segments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(Triangle), [<span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>)]).
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>).
</span></span></code></pre></div><p>Or reject sets of graphical primitives that do not form a triangle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(Triangle), [<span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>)]).
</span></span><span style=display:flex><span><span style=color:#e6db74>false</span>.
</span></span></code></pre></div><p>Or test that a specific triangle is related to a set of segments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>triangle</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>)), [<span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>)]).
</span></span><span style=display:flex><span><span style=color:#e6db74>true</span>.
</span></span><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>triangle</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>)), [<span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>)]).
</span></span><span style=display:flex><span><span style=color:#e6db74>false</span>.
</span></span></code></pre></div><h2 id=the-ordering-problem>The ordering problem</h2><p>Unfortunately, our DCG clause <code>triangle_dcg</code> is too strict about the possible segment lists we can use to build a triangle.
For example, the following query fails:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(Triangle), [<span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>)]).
</span></span><span style=display:flex><span><span style=color:#e6db74>false</span>.
</span></span></code></pre></div><p>There is no reason why segment BC should be before segment CA.
This is especially true when manipulating graphical primitives.
There is no evident ordering of the primitives, and we cannot assume a specific ordering when defining our grammar.</p><p>In order to fix this, we will define a predicate <code>term</code> which job will be to find and consume a given graphical primitive:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>term</span>(X) --&gt;
</span></span><span style=display:flex><span>   [X].
</span></span><span style=display:flex><span><span style=color:#a6e22e>term</span>(X), [CurX] --&gt;
</span></span><span style=display:flex><span>   [CurX],
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(X).
</span></span></code></pre></div><p>The first clause tries to match the given primitive <code>X</code>.
If it fails, we go to the second clause and skip the current element <code>CurX</code> and try to match the next element by doing a recursive call.
Coincidentally, the standard <code>select/3</code> predicate can be used instead transparently and will do exactly the same thing.</p><p>Now, let&rsquo;s rewrite our <code>triangle_dcg//1</code> DCG predicate to use <code>term//1</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>triangle_dcg</span>(Triangle) --&gt;
</span></span><span style=display:flex><span>   { <span style=color:#a6e22e>triangle_cond</span>(Triangle, Seg1, Seg2, Seg3) },
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg1),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg2),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg3).
</span></span></code></pre></div><p>Let&rsquo;s retry our most general query:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(Triangle), L, R).
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C),
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A)|R] ;
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C),
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C), <span style=color:#66d9ef>_</span>D, <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A)|<span style=color:#66d9ef>_</span>E],
</span></span><span style=display:flex><span>R <span style=color:#f92672>=</span> [<span style=color:#66d9ef>_</span>D|<span style=color:#66d9ef>_</span>E] 
</span></span><span style=display:flex><span>Action (<span style=color:#e6db74>h</span> <span style=color:#e6db74>for</span> <span style=color:#e6db74>help</span>) <span style=color:#e6db74>?</span> <span style=color:#e6db74>abort</span>
</span></span><span style=display:flex><span><span style=color:#75715e>% Execution Aborted</span>
</span></span></code></pre></div><p>As you can see, the first solution is the same as our previous result but now, we get multiple other solutions.
In fact, we get an infinity many more solutions.
From this little change in the code, we went from a single deterministic solution to infinitely many.
This can be good, because it will allow us to get more solutions as we will see below.
This could be also bad, since the complexity of the code has risen dramatically and it could be quite easy to be trapped into an infinite recursion loop.
But we will worry about this later.</p><p>One new characteristic of the second results is that the grammar is now resistant to noise, i.e. non relevant graphical primitives.</p><p>In the query above, we enumerate the solutions in a depth first manner, lengthening the list to infinity by searching for the last segment deeper and deeper.
Instead, a breadth first search strategy could give us some more interesting solutions.
This can be done by using the <code>length/2</code> predicate before the call to <code>phrase/3</code>.
Let&rsquo;s see all solutions with a list <code>L</code> of length 3:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>length</span>(L, <span style=color:#ae81ff>3</span>), <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(Triangle), L, R).
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A)],
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C),
</span></span><span style=display:flex><span>R <span style=color:#f92672>=</span> [] ;
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C)],
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C),
</span></span><span style=display:flex><span>R <span style=color:#f92672>=</span> [] ;
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C)],
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B),
</span></span><span style=display:flex><span>R <span style=color:#f92672>=</span> [] ;
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A)],
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A),
</span></span><span style=display:flex><span>R <span style=color:#f92672>=</span> [] ;
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A)],
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B),
</span></span><span style=display:flex><span>R <span style=color:#f92672>=</span> [] ;
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A), <span style=color:#a6e22e>seg</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C)],
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#66d9ef>_</span>B, <span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>A),
</span></span><span style=display:flex><span>R <span style=color:#f92672>=</span> [] ;
</span></span><span style=display:flex><span><span style=color:#e6db74>false</span>.
</span></span></code></pre></div><p>If you count them, that&rsquo;s 6 solutions which are all the permutations of list of length 3 with no replacements.</p><p>So, we can post our previous wrongly failing query it should now work:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(Triangle), [<span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>), <span style=color:#a6e22e>seg</span>(<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>)]).
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>) ;
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>) ;
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>triangle</span>(<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>) ;
</span></span><span style=display:flex><span><span style=color:#e6db74>false</span>.
</span></span></code></pre></div><p>Great, it even gave us all the different representation of the ABC triangle!</p><p>Let&rsquo;s move on to another type of triangle, the equilateral triangle.</p><h2 id=the-equilateral-triangle>The equilateral triangle</h2><p>The property of an equilateral triangle is that all three sides have the same length.
Let&rsquo;s define the compound term for such a triangle:</p><ul><li>an equilateral triangle ABC: <code>equilateral_triangle(A, B, C)</code></li></ul><p>And let&rsquo;s extend the <code>triangle_cond/4</code> predicate to relate such a triangle with its three sides:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>equilateral_triangle</span>(A, B, C), Seg1, Seg2, Seg3) :-
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>triangle_cond</span>(<span style=color:#a6e22e>triangle</span>(A, B, C), Seg1, Seg2, Seg3),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>seg_length</span>(Seg1, Len),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>seg_length</span>(Seg2, Len),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>seg_length</span>(Seg3, Len).
</span></span></code></pre></div><p>We first reuse the <code>triangle_cond/4</code> first clause since an equilateral triangle is itself a triangle.
This will correctly setup the three segments with the triangle points.
Next, we unify all three segment length to the same length <code>Len</code> using the yet to be defined <code>seg_length/2</code> predicate.</p><p>To compute a segment length, we will use the well known Pythagoras theorem:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>seg_length</span>(<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(X1, Y1), <span style=color:#a6e22e>point</span>(X2, Y2)), Len) :-
</span></span><span style=display:flex><span>   Len <span style=color:#f92672>is</span> <span style=color:#a6e22e>sqrt</span>((X2 <span style=color:#f92672>-</span> X1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (Y2 <span style=color:#f92672>-</span> Y1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span>).
</span></span></code></pre></div><p>This predicate will only work on 2D segments, but we have to start from somewhere.</p><p>Let&rsquo;s try our new equilateral triangle predicate with the most general query:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(A, B, C)), L, R).
</span></span><span style=display:flex><span>ERROR<span style=color:#e6db74>:</span> Arguments <span style=color:#e6db74>are</span> <span style=color:#f92672>not</span> <span style=color:#e6db74>sufficiently</span> <span style=color:#e6db74>instantiated</span>
</span></span><span style=display:flex><span>ERROR<span style=color:#e6db74>:</span> In<span style=color:#e6db74>:</span>
</span></span><span style=display:flex><span>ERROR<span style=color:#e6db74>:</span>   [<span style=color:#ae81ff>15</span>] <span style=color:#66d9ef>_</span><span style=color:#ae81ff>31816</span> <span style=color:#f92672>is</span> <span style=color:#a6e22e>sqrt</span>((...)<span style=color:#e6db74>+</span>(...))
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Well&mldr; As you probably would have predicted, reality hit us on the face with the fact that prolog arithmetic is not pure.
It will only work in a single direction.
So one solution would be to try and modify the order of predicates in the DCG like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a6e22e>triangle_dcg</span>(Triangle) --&gt;
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg1),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg2),
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>term</span>(Seg3),
</span></span><span style=display:flex><span>   { <span style=color:#a6e22e>triangle_cond</span>(Triangle, Seg1, Seg2, Seg3) }.
</span></span></code></pre></div><p>In this case, <code>triangle_cond/4</code> would become a post condition instead of a precondition.
However, the search strategy of the grammar would become a kind of generate and test strategy, which would be intractable with only a small number of graphical primitives.
In situation like this, modern prolog has come up with a solution called <strong>Constraints</strong>.</p><h2 id=constraints-programming>Constraints programming</h2><p>The idea of constraint programming is to specify as early as possible a maximum of knowledge about the problem at hand.
This knowledge can be used to prune the search tree and find results with less computation.
A very well known type of constraint programming is constraints over integers with libraries like <a href="https://www.swi-prolog.org/pldoc/man?section=clpfd"><code>clpfd</code></a>.
A very useful byproduct of such library is that it introduce pure arithmetic, with arithmetic operations that can be used in any direction.
That&rsquo;s perfect for what we want to do!</p><p>However, our problem domain is not over integers but over reals.
Coordinates or segment lengths are continuous values in the euclidean 2D space.
From my current knowledge about the swi-prolog landscape, I only know of 2 libraries that does constraint programming over reals:</p><ul><li><a href="https://www.swi-prolog.org/pldoc/man?section=clpqr"><code>clpqr</code></a> installed by default in the swi-prolog</li><li><a href=https://github.com/ridgeworks/clpBNR><code>clpBNR</code></a> which you can install as a pack in swi-prolog</li></ul><p><code>clpqr</code> idea is to delay the evaluation of an operation until all input arguments are ground.
This make the constraint propagation very weak, which is a big problem for us.</p><p>On the other hand, <code>clpBNR</code> takes another approach, closer to the one used by <code>clpfd</code> by using interval arithmetic.
In this case, constraint propagation are much stronger at the expense of results precision.
If you want to know more, you should have a read at the <a href=https://ridgeworks.github.io/clpBNR/CLP_BNR_Guide/CLP_BNR_Guide.html>Guide to <code>clpBNR</code></a>.</p><p>To come back to our grammar, <code>cplBNR</code> will allow us to use real arithmetic in all directions.
This will come at the expense of efficiency and somewhat imprecise results.</p><p>Let&rsquo;s try to rework our <code>seg_length/2</code> predicate to use <code>clpBNR</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>:- <span style=color:#a6e22e>use_module</span>(<span style=color:#a6e22e>library</span>(<span style=color:#e6db74>clpBNR</span>)).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>seg_length</span>(<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(X1, Y1), <span style=color:#a6e22e>point</span>(X2, Y2)), Len) :-
</span></span><span style=display:flex><span>   { Len <span style=color:#f92672>==</span> <span style=color:#a6e22e>sqrt</span>((X2 <span style=color:#f92672>-</span> X1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (Y2 <span style=color:#f92672>-</span> Y1)<span style=color:#e6db74>**</span><span style=color:#ae81ff>2</span>) }.
</span></span></code></pre></div><p>First of all, the braces <code>{}</code> wrapping the mathematical expression is to indicate that we are using <code>clpBNR</code> arithmetic.
Next, we have replace the <code>is</code> operator with <code>==</code> equality operator.
With pure arithmetic, it does not make sense anymore to have an evaluation predicate since there are no predefined direction on how to evaluate things.
All you can do is to use comparison predicate such as equality <code>==</code> to say that both sides should be equal.</p><p>Let&rsquo;s try our new predicate with the most general query:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>seg_length</span>(Seg, Len).
</span></span><span style=display:flex><span>Seg <span style=color:#f92672>=</span> <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>D)),
</span></span><span style=display:flex><span>Len<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>C<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>A<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>D<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>B<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf).
</span></span></code></pre></div><p>The last four lines tells us that the segment coordinates can take real values going from -infinity to infinity.
If we look at the <code>Len</code> variable, we can already see some constraint propagation happening!
<code>clpBNR</code> correctly deduced that <code>Len</code> is related to the output of the square root function which can only be positive&mldr;
Well, not in math, but in computers, the <code>sqrt</code> often only returns the non negative square root only.
In our application of computing the length of a segment, this is exactly what we want, since a negative segment length would not make sense.</p><p>Let&rsquo;s try some more queries, by adding some more information about the segment first point and the segment length <em>after</em> the call to <code>seg_length/2</code> to see some more constraint propagations:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>seg_length</span>(Seg, Len), Seg <span style=color:#f92672>=</span> <span style=color:#a6e22e>seg</span>(P1, P2), P1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), Len<span style=color:#f92672>=</span><span style=color:#ae81ff>1.</span>
</span></span><span style=display:flex><span>Seg <span style=color:#f92672>=</span> <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B)),
</span></span><span style=display:flex><span>Len <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>P1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>P2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>A<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>B<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>).
</span></span></code></pre></div><p>With this, <code>clpBNR</code> has correctly deduced that the end point of <code>Seg</code> can by anywhere between <code>(-1, 1)</code>.
In fact, this second point has to be on the <em>circle</em> of center (0, 0) and radius 1:</p><div id=jxgbox2 class=jxgbox style=width:400px;height:400px></div><script type=text/javascript>var board2=JXG.JSXGraph.initBoard("jxgbox2",{boundingbox:[-2,2,2,-2],axis:!0}),p=board2.create("point",[0,0],{name:"P1"}),ci=board2.createElement("circle",["P1",1],{strokeColor:"#00ff00",strokeWidth:2})</script><p>Now that we have pure real arithmetic, let&rsquo;s go back to our definition of an equilateral triangle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(A, B, C)), L, R).
</span></span><span style=display:flex><span>A <span style=color:#f92672>=</span> <span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), B <span style=color:#f92672>=</span> <span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>D), C <span style=color:#f92672>=</span> <span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>E, <span style=color:#66d9ef>_</span>F),
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B), <span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>D)), <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>C, <span style=color:#66d9ef>_</span>D), <span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>E, <span style=color:#66d9ef>_</span>F)), <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>E, <span style=color:#66d9ef>_</span>F), <span style=color:#a6e22e>point</span>(<span style=color:#66d9ef>_</span>A, <span style=color:#66d9ef>_</span>B))|R],
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>C<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>A<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>D<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>B<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>E<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf),
</span></span><span style=display:flex><span><span style=color:#66d9ef>_</span>F<span style=color:#e6db74>::</span><span style=color:#a6e22e>real</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>Inf, <span style=color:#ae81ff>1.0</span>Inf) .
</span></span></code></pre></div><p>Success!
Can we now <em>draw</em> an equilateral triangle using from a fully ground triangle ?
Here is an example of an equilateral triangle A, B, C of with side length of 2:</p><ul><li>point A (0, 0)</li><li>point B (2, 0)</li><li>point C (1, sqrt(3))</li></ul><div id=jxgbox3 class=jxgbox style=width:400px;height:400px></div><script type=text/javascript>var board=JXG.JSXGraph.initBoard("jxgbox3",{boundingbox:[-1,4,4,-1],axis:!0}),p=board.create("point",[0,0],{name:"A"}),p=board.create("point",[2,0],{name:"B"}),p=board.create("point",[1,1.732051],{name:"C"}),li=board.create("line",["A","B"],{straightFirst:!1,straightLast:!1,strokeColor:"#000000",strokeWidth:2}),li=board.create("line",["B","C"],{straightFirst:!1,straightLast:!1,strokeColor:"#000000",strokeWidth:2}),li=board.create("line",["C","A"],{straightFirst:!1,straightLast:!1,strokeColor:"#000000",strokeWidth:2})</script><p>So this <em>should</em> work ?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>sqrt</span>(<span style=color:#ae81ff>3</span>)))), L, R).
</span></span><span style=display:flex><span>L <span style=color:#f92672>=</span> [<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>)), <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>sqrt</span>(<span style=color:#ae81ff>3</span>))), <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>sqrt</span>(<span style=color:#ae81ff>3</span>)), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))|R] .
</span></span></code></pre></div><p>Yes, and we should be able to recognize an equilateral triangle from its segments too:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?-</span> {Y <span style=color:#f92672>==</span> <span style=color:#a6e22e>sqrt</span>(<span style=color:#ae81ff>3</span>)},
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>phrase</span>(<span style=color:#a6e22e>triangle_dcg</span>(<span style=color:#a6e22e>equilateral_triangle</span>(A, B, C)),
</span></span><span style=display:flex><span>          [<span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, Y)),
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>seg</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, Y), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))]).
</span></span><span style=display:flex><span>Triangle <span style=color:#f92672>=</span> <span style=color:#a6e22e>equilateral_triangle</span>(<span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>), <span style=color:#a6e22e>point</span>(<span style=color:#ae81ff>1</span>, Y)),
</span></span><span style=display:flex><span>Y<span style=color:#e6db74>::</span> <span style=color:#ae81ff>1.732050807568877</span>... .
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>
We precompute <code>sqrt(3)</code> because <code>clpBNR</code> does not support expression for attributed variables, only numbers.</p></blockquote><p>Nice!</p><h1 id=conclusion>Conclusion</h1><p>In this article, I have introduced a way to write pure prolog grammar to relate geometrical figures with a list of their graphical primitives by combining the DCG notation and constraint programming.
Stay tune for the next blog post of this subject!</p></article></main><footer>© 2024 Kwon-Young Choi
<a rel=license href=http://creativecommons.org/licenses/by/3.0/us/><img alt="Creative Commons License" src=https://i.creativecommons.org/l/by/3.0/us/80x15.png></a></footer></div></body></html>